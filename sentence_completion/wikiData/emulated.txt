This article is about emulators in computing.  For a line of digital musical instruments, see E-mu Emulator.  For the Transformers character, see Circuit Breaker (Transformers)#Shattered Glass.  For other uses, see Emulation (disambiguation).     DOSBox emulates the command-line interface of DOS.   In computing, an emulator is hardware or software that enables one computer system (called the host) to behave like another computer system (called the guest). An emulator typically enables the host system to run software or use peripheral devices designed for the guest system.    Contents   1 Emulators in computing 2 Emulation in preservation  2.1 Benefits 2.2 Obstacles   3 Emulators in new media art 4 Emulation in future systems design 5 Types of emulators 6 Structure of an emulator  6.1 Memory subsystem 6.2 CPU simulator 6.3 I/O   7 Emulation versus simulation 8 Logic simulators 9 Functional simulators 10 Video game console emulators 11 Terminal emulators 12 In literature 13 Legal issues 14 See also 15 Notes 16 References 17 External links    Emulators in computing[edit]   “ "Can a Commodore 64 emulate MS-DOS?" Yes, it's possible for a 64 to emulate an IBM PC, in the same sense that it's possible to bail out Lake Michigan with a teaspoon.  ”    —Letter to Compute! and editorial answer, April 1988[1]    Emulation refers to the ability of a computer program in an electronic device to emulate (imitate) another program or device. Many printers, for example, are designed to emulate Hewlett-Packard LaserJet printers because so much software is written for HP printers. If a non-HP printer emulates an HP printer, any software written for a real HP printer will also run in the non-HP printer emulation and produce equivalent printing. A hardware emulator is an emulator which takes the form of a hardware device. Examples include the DOS-compatible card installed in some old-world Macintoshes like Centris 610 or Performa 630 that allowed them to run PC programs and FPGA-based hardware emulators. In a theoretical sense, the Church-Turing thesis implies that (under the assumption that enough memory is available) any operating environment can be emulated within any other. However, in practice, it can be quite difficult, particularly when the exact behavior of the system to be emulated is not documented and has to be deduced through reverse engineering. It also says nothing about timing constraints; if the emulator does not perform as quickly as the original hardware, the emulated software may run much more slowly than it would have on the original hardware, possibly triggering time interrupts that alter performance. Emulation in preservation[edit] Emulation is a strategy in digital preservation to combat obsolescence. Emulation focuses on recreating an original computer environment, which can be time-consuming and difficult to achieve, but valuable because of its ability to maintain a closer connection to the authenticity of the digital object.[2] Emulation addresses the original hardware and software environment of the digital object, and recreates it on a current machine.[3] The emulator allows the user to have access to any kind of application or operating system on a current platform, while the software runs as it did in its original environment.[4] Jeffery Rothenberg, an early proponent of emulation as a digital preservation strategy states, "the ideal approach would provide a single extensible, long-term solution that can be designed once and for all and applied uniformly, automatically, and in synchrony (for example, at every refresh cycle) to all types of documents and media".[5] He further states that this should not only apply to out of date systems, but also be upwardly mobile to future unknown systems.[6] Practically speaking, when a certain application is released in a new version, rather than address compatibility issues and migration for every digital object created in the previous version of that application, one could create an emulator for the application, allowing access to all of said digital objects. Benefits[edit]     Basilisk II emulates a Macintosh 68k using interpretation code and dynamic recompilation.    Potentially better graphics quality than original hardware. Potentially additional features original hardware didn't have. Save states Emulators allow users to play games for discontinued consoles. Emulators maintain the original look, feel, and behavior of the digital object, which is just as important as the digital data itself.[7] Despite the original cost of developing an emulator, it may prove to be the more cost efficient solution over time.[8] Reduces labor hours, because rather than continuing an ongoing task of continual data migration for every digital object, once the library of past and present operating systems and application software is established in an emulator, these same technologies are used for every document using those platforms.[4] Many emulators have already been developed and released under GNU General Public License through the open source environment, allowing for wide scale collaboration.[9] Emulators allow software exclusive to one system to be used on another. For example, a PlayStation 2 exclusive video game could be played on a PC using an emulator. This is especially useful when the original system is difficult to obtain, or incompatible with modern equipment (e.g. old video game consoles which connect via analog outputs may be unable to connect to modern TVs which may only have digital inputs).  Obstacles[edit]  Intellectual property - Many technology vendors implemented non-standard features during program development in order to establish their niche in the market, while simultaneously applying ongoing upgrades to remain competitive. While this may have advanced the technology industry and increased vendor's market share, it has left users lost in a preservation nightmare with little supporting documentation due to the proprietary nature of the hardware and software.[10] Copyright laws are not yet in effect to address saving the documentation and specifications of proprietary software and hardware in an emulator module.[11] Emulators are often used as a copyright infringement tool, since they allow users to play video games without having to buy the console, and rarely make any attempt to prevent the use of illegal copies. This leads to a number of legal uncertainties regarding emulation, and leads to software being programmed to refuse to work if it can tell the host is an emulator; some video games in particular will continue to run, but not allow the player to progress beyond some late stage in the game, often appearing to be faulty or just extremely difficult.[12][13] These protections make it more difficult to design emulators, since they must be accurate enough to avoid triggering the protections, whose effects may not be obvious. Emulators require better hardware than the original system has.  Emulators in new media art[edit] Because of its primary use of digital formats, new media art relies heavily on emulation as a preservation strategy. Artists such as Cory Arcangel specialize in resurrecting obsolete technologies in their artwork and recognize the importance of a decentralized and deinstitutionalized process for the preservation of digital culture. In many cases, the goal of emulation in new media art is to preserve a digital medium so that it can be saved indefinitely and reproduced without error, so that there is no reliance on hardware that ages and becomes obsolete. The paradox is that the emulation and the emulator have to be made to work on future computers.[14] Emulation in future systems design[edit] Main article: Full system simulation Emulation techniques are commonly used during the design and development of new systems. It eases the development process by providing the ability to detect, recreate and repair flaws in the design even before the system is actually built.[15] It is particularly useful in the design of multi-cores systems, where concurrency errors can be very difficult to detect and correct without the controlled environment provided by virtual hardware.[16] This also allows the software development to take place before the hardware is ready,[17] thus helping to validate design decisions. Types of emulators[edit]     Windows XP running an Acorn Archimedes emulator, which is in turn running a Sinclair ZX Spectrum emulator.       Tetris running on the Wzonka-Lad GameBoy emulator on AmigaOS, itself running on E-UAE on a modern Fedora Linux system.   Most emulators just emulate a hardware architecture—if operating system firmware or software is required for the desired software, it must be provided as well (and may itself be emulated). Both the OS and the software will then be interpreted by the emulator, rather than being run by native hardware. Apart from this interpreter for the emulated binary machine's language, some other hardware (such as input or output devices) must be provided in virtual form as well; for example, if writing to a specific memory location should influence what is displayed on the screen, then this would need to be emulated. While emulation could, if taken to the extreme, go down to the atomic level, basing its output on a simulation of the actual circuitry from a virtual power source, this would be a highly unusual solution. Emulators typically stop at a simulation of the documented hardware specifications and digital logic. Sufficient emulation of some hardware platforms requires extreme accuracy, down to the level of individual clock cycles, undocumented features, unpredictable analog elements, and implementation bugs. This is particularly the case with classic home computers such as the Commodore 64, whose software often depends on highly sophisticated low-level programming tricks invented by game programmers and the demoscene. In contrast, some other platforms have had very little use of direct hardware addressing. In these cases, a simple compatibility layer may suffice. This translates system calls for the emulated system into system calls for the host system e.g., the Linux compatibility layer used on *BSD to run closed source Linux native software on FreeBSD, NetBSD and OpenBSD. For example, while the Nintendo 64 graphic processor was fully programmable, most games used one of a few pre-made programs, which were mostly self-contained and communicated with the game via FIFO; therefore, many emulators do not emulate the graphic processor at all, but simply interpret the commands received from the CPU as the original program would. Developers of software for embedded systems or video game consoles often design their software on especially accurate emulators called simulators before trying it on the real hardware. This is so that software can be produced and tested before the final hardware exists in large quantities, so that it can be tested without taking the time to copy the program to be debugged at a low level and without introducing the side effects of a debugger. In many cases, the simulator is actually produced by the company providing the hardware, which theoretically increases its accuracy. Math coprocessor emulators allow programs compiled with math instructions to run on machines that don't have the coprocessor installed, but the extra work done by the CPU may slow the system down. If a math coprocessor isn't installed or present on the CPU, when the CPU executes any coprocessor instruction it will make a determined interrupt (coprocessor not available), calling the math emulator routines. When the instruction is successfully emulated, the program continues executing. Structure of an emulator[edit]      This article's section named "Structure of an emulator" needs additional citations for verification. Please help improve this article by adding citations to reliable sources. Unsourced material may be challenged and removed. (June 2008)   Typically, an emulator is divided into modules that correspond roughly to the emulated computer's subsystems. Most often, an emulator will be composed of the following modules:  a CPU emulator or CPU simulator (the two terms are mostly interchangeable in this case), unless the target being emulated has the same CPU architecture as the host, in which case a virtual machine layer may be used instead a memory subsystem module various I/O devices emulators  Buses are often not emulated, either for reasons of performance or simplicity, and virtual peripherals communicate directly with the CPU or the memory subsystem. Memory subsystem[edit] It is possible for the memory subsystem emulation to be reduced to simply an array of elements each sized like an emulated word; however, this model falls very quickly as soon as any location in the computer's logical memory does not match physical memory. This clearly is the case whenever the emulated hardware allows for advanced memory management (in which case, the MMU logic can be embedded in the memory emulator, made a module of its own, or sometimes integrated into the CPU simulator). Even if the emulated computer does not feature an MMU, though, there are usually other factors that break the equivalence between logical and physical memory: many (if not most) architectures offer memory-mapped I/O; even those that do not often have a block of logical memory mapped to ROM, which means that the memory-array module must be discarded if the read-only nature of ROM is to be emulated. Features such as bank switching or segmentation may also complicate memory emulation. As a result, most emulators implement at least two procedures for writing to and reading from logical memory, and it is these procedures' duty to map every access to the correct location of the correct object. On a base-limit addressing system where memory from address 0 to address ROMSIZE-1 is read-only memory, while the rest is RAM, something along the line of the following procedures would be typical:    void WriteMemory(word Address, word Value) {     word RealAddress;     RealAddress = Address + BaseRegister;     if ((RealAddress < LimitRegister) &&         (RealAddress > ROMSIZE)) {         Memory[RealAddress] = Value;     } else {         RaiseInterrupt(INT_SEGFAULT);     } }      word ReadMemory(word Address) {     word RealAddress;     RealAddress=Address+BaseRegister;     if (RealAddress < LimitRegister) {         return Memory[RealAddress];     } else {         RaiseInterrupt(INT_SEGFAULT);         return NULL;     } }   CPU simulator[edit] The CPU simulator is often the most complicated part of an emulator. Many emulators are written using "pre-packaged" CPU simulators, in order to concentrate on good and efficient emulation of a specific machine. The simplest form of a CPU simulator is an interpreter, which is a computer program that follows the execution flow of the emulated program code and, for every machine code instruction encountered, executes operations on the host processor that are semantically equivalent to the original instructions. This is made possible by assigning a variable to each register and flag of the simulated CPU. The logic of the simulated CPU can then more or less be directly translated into software algorithms, creating a software re-implementation that basically mirrors the original hardware implementation. The following example illustrates how CPU simulation can be accomplished by an interpreter. In this case, interrupts are checked-for before every instruction executed, though this behavior is rare in real emulators for performance reasons (it is generally faster to use a subroutine to do the work of an interrupt).    void Execute(void) {     if (Interrupt != INT_NONE) {         SuperUser = TRUE;         WriteMemory(++StackPointer, ProgramCounter);         ProgramCounter = InterruptPointer;     }     switch (ReadMemory(ProgramCounter++)) {         /*          * Handling of every valid instruction          * goes here...          */         default:         Interrupt = INT_ILLEGAL;     } }   Interpreters are very popular as computer simulators, as they are much simpler to implement than more time-efficient alternative solutions, and their speed is more than adequate for emulating computers of more than roughly a decade ago on modern machines. However, the speed penalty inherent in interpretation can be a problem when emulating computers whose processor speed is on the same order of magnitude as the host machine[dubious – discuss]. Until not many years ago, emulation in such situations was considered completely impractical by many[dubious – discuss]. What allowed breaking through this restriction were the advances in dynamic recompilation techniques[dubious – discuss]. Simple a priori translation of emulated program code into code runnable on the host architecture is usually impossible because of several reasons:  code may be modified while in RAM, even if it is modified only by the emulated operating system when loading the code (for example from disk) there may not be a way to reliably distinguish data (which should not be translated) from executable code.  Various forms of dynamic recompilation, including the popular Just In Time compiler (JIT) technique, try to circumvent these problems by waiting until the processor control flow jumps into a location containing untranslated code, and only then ("just in time") translates a block of the code into host code that can be executed. The translated code is kept in a code cache[dubious – discuss], and the original code is not lost or affected; this way, even data segments can be (meaninglessly) translated by the recompiler, resulting in no more than a waste of translation time. Speed may not be desirable as some older games were not designed with the speed of faster computers in mind. A game designed for a 30 MHz PC with a level timer of 300 game seconds might only give the player 30 seconds on a 300 MHz PC. Other programs, such as some DOS programs, may not even run on faster computers. Particularly when emulating computers which were "closed-box", in which changes to the core of the system were not typical, software may use techniques that depend on specific characteristics of the computer it ran on (i.e. its CPU's speed) and thus precise control of the speed of emulation is important for such applications to be properly emulated. I/O[edit] Most emulators do not, as mentioned earlier, emulate the main system bus; each I/O device is thus often treated as a special case, and no consistent interface for virtual peripherals is provided. This can result in a performance advantage, since each I/O module can be tailored to the characteristics of the emulated device; designs based on a standard, unified I/O API can, however, rival such simpler models, if well thought-out, and they have the additional advantage of "automatically" providing a plug-in service through which third-party virtual devices can be used within the emulator. A unified I/O API may not necessarily mirror the structure of the real hardware bus: bus design is limited by several electric constraints and a need for hardware concurrency management that can mostly be ignored in a software implementation. Even in emulators that treat each device as a special case, there is usually a common basic infrastructure for:  managing interrupts, by means of a procedure that sets flags readable by the CPU simulator whenever an interrupt is raised, allowing the virtual CPU to "poll for (virtual) interrupts" writing to and reading from physical memory, by means of two procedures similar to the ones dealing with logical memory (although, contrary to the latter, the former can often be left out, and direct references to the memory array be employed instead)  Emulation versus simulation[edit] The word "emulator" was coined in 1963 at IBM[18] during development of the NPL (IBM 360) product line, using a "new combination of software, microcode, and hardware".[19] They discovered that using microcode hardware instead of software simulation, to execute programs written for earlier IBM computers, dramatically increased simulation speed. Earlier, IBM provided simulators for, e.g., the 650 on the 705.[20] In addition to simulators, IBM had compatibility features on the 709 and 7090,[21] for which it provided the IBM 709 computer with a program to run legacy programs written for the IBM 704 on the 709 and later on the IBM 7090. This program used the instructions added by the compatibility feature[22] to trap instructions requiring special handling; all other 704 instructions ran the same on a 7090. The compatibility feature on the 1410[23] only required setting a console toggle switch, not a support program. In 1963, when microcode was first used to speed up this simulation process, IBM engineers coined the term "emulator" to describe the concept. It has recently become common to use the word "emulate" in the context of software. However, before 1980, "emulation" referred only to emulation with a hardware or microcode assist, while "simulation" referred to pure software emulation.[24] For example, a computer specially built for running programs designed for another architecture is an emulator. In contrast, a simulator could be a program which runs on a PC, so that old Atari games can be simulated on it. Purists continue to insist on this distinction, but currently the term "emulation" often means the complete imitation of a machine executing binary code while "simulation" often refers to computer simulation, where a computer program is used to simulate an abstract model. Computer simulation is used in virtually every scientific and engineering domain and Computer Science is no exception, with several projects simulating abstract models of computer systems, such as network simulation. Logic simulators[edit] Main article: Logic simulation Logic simulation is the use of a computer program to simulate the operation of a digital circuit such as a processor. This is done after a digital circuit has been designed in logic equations, but before the circuit is fabricated in hardware. Functional simulators[edit] Main article: High level emulation Functional simulation is the use of a computer program to simulate the execution of a second computer program written in symbolic assembly language or compiler language, rather than in binary machine code. By using a functional simulator, programmers can execute and trace selected sections of source code to search for programming errors (bugs), without generating binary code. This is distinct from simulating execution of binary code, which is software emulation. The first functional simulator was written by Autonetics about 1960 for testing assembly language programs for later execution in military computer D-17B. This made it possible for flight programs to be written, executed, and tested before D-17B computer hardware had been built. Autonetics also programmed a functional simulator for testing flight programs for later execution in the military computer D-37C. Video game console emulators[edit] Main article: Video game console emulator Video game console emulators are programs that allow a personal computer or video game console to emulate another video game console. They are most often used to play older video games on personal computers and more contemporary video game consoles, but they are also used to translate games into other languages, to modify existing games, and in the development process of home brew demos and new games for older systems. The internet has helped in the spread of console emulators, as most - if not all - would be unavailable for sale in retail outlets. Examples of console emulators that have been released in the last 2 decades are: Dolphin, PCSX2, PPSSPP, Zsnes, Kega Fusion, Desmume, Epsxe, Project64, Visual Boy Advance, NullDC and Nestopia. Terminal emulators[edit] Main article: Terminal emulator Terminal emulators are software programs that provide modern computers and devices interactive access to applications running on mainframe computer operating systems or other host systems such as HP-UX or OpenVMS. Terminals such as the IBM 3270 or VT100 and many others, are no longer produced as physical devices. Instead, software running on modern operating systems simulates a "dumb" terminal and is able to render the graphical and text elements of the host application, send keystrokes and process commands using the appropriate terminal protocol. Some terminal emulation applications include Attachmate Reflection, IBM Personal Communications, and Micro Focus Rumba. In literature[edit] Vernor Vinge's 1999 novel A Deepness in the Sky depicts a human interstellar culture that relies on software written over five thousand years, some from "before Humankind ever left Earth". Its computers still "can run most of them" through "a million million circuitous threads of inheritance ... layers upon layers of support". "Down at the very bottom" of the culture's "incredibly complex" timekeeping systems, for example, "was a little program that ran a counter [from] the 0-second of one of Humankind's first computer operating systems". Programmer-archaeologists find and modify old software written hundreds of years ago (one character states that "all of them are buggy") to solve modern problems.[25] Legal issues[edit]  See article Console emulator — Legal issues  See also[edit]  The list of emulators The list of video game emulators The list of computer system emulators Computer simulation is the larger field of modeling real-world phenomenon (e.g. physics and economy) using computers. Other uses of the term "emulator" in the field of computer science:  Console emulator Flash emulator Instruction set simulator Network emulation Server emulator Terminal emulator   Semulation Logic simulation Functional simulation Translation:  Binary translation     In-circuit emulator (ICE)  Joint Test Action Group Background Debug Mode interface     QEMU Q (emulator) Hardware emulation Hardware-assisted virtualization Virtual machine  Notes[edit]  References[edit]   ^ Warick, Mike (April 1988). "MS-DOS Emulation For The 64". Compute!. p. 43. Retrieved 10 November 2013.  ^ "What is emulation?". Koninklijke Bibliotheek. Retrieved 2007-12-11.  ^ van der Hoeven, Jeffrey, Bram Lohman, and Remco Verdegem. "Emulation for Digital Preservation in Practice: The Results." The International Journal of Digital Curation 2.2 (2007): 123-132. ^ a b Muira, Gregory. " Pushing the Boundaries of Traditional Heritage Policy: maintaining long-term access to multimedia content." IFLA Journal 33 (2007): 323-326. ^ Rothenberg, Jeffrey (1998). ""Criteria for an Ideal Solution." Avoiding Technological Quicksand: Finding a Viable Technical Foundation for Digital Preservation.". Council on Library and Information Resources. Washington, DC. Retrieved 2008-03-08.  ^ Rothenberg, Jeffrey. "The Emulation Solution." Avoiding Technological Quicksand: Finding a Viable Technical Foundation for Digital Preservation. Washington, DC: Council on Library and Information Resources, 1998. Council on Library and Information Resources. 2008. 28 Mar. 2008 http://www.clir.org/pubs/reports/rothenberg/contents.html ^ Muira, Gregory." Pushing the Boundaries of Traditional Heritage Policy: maintaining long-term access to multimedia content." IFLA Journal 33 (2007): 323-326. ^ Granger, Stewart. Digital Preservation & Emulation: from theory to practice. Proc. of the ichim01 Meeting, vol. 2, 3 -7 Sept. 2001. Milano, Italy. Toronto: Archives and Museum Informatics, University of Toronto, 2001. 28 Mar. 2008 http://www.leeds.ac.uk/cedars/pubconf/papers/ichim01SG.html ^ van der Hoeven, Jeffrey, Bram Lohman, and Remco Verdegem. "Emulation for Digital Preservation in Practice: The Results." The International Journal of Digital Curation 2.2 (2007): 123-132. ^ Granger, Stewart. "Emulation as a Digital Preservation Strategy." D-Lib Magazine 6.19 (2000). 29 Mar 2008 http://www.dlib.org/dlib/october00/granger/10granger.html ^ Rothenberg, Jeffrey. "The Emulation Solution." Avoiding Technological Quicksand: Finding a Viable Technical Foundation for Digital Preservation. Washington, DC: Council on Library and Information Resources, 1998. Council on Library and Information Resources. 2008. 28 Mar. 2008 ^ http://tcrf.net/Pok%C3%A9mon_Black_and_White#Anti-Piracy ^ http://tcrf.net/Mega_Man_Star_Force#Anti-Piracy ^ "Echoes of Art: Emulation as preservation strategy". Retrieved 2007-12-11.  ^ Peter Magnusson (2004). "Full System Simulation: Software Development's Missing Link".  ^ "Debugging and Full System Simulation".  ^ Vania Joloboff (2009). "Full System Simulation of Embedded Systems" (PDF).  ^ Pugh, Emerson W. (1995). Building IBM: Shaping an Industry and Its Technology. MIT. p. 274. ISBN 0-262-16147-8.  ^ Pugh, Emerson W. et al. (1991). IBM's 360 and Early 370 Systems. MIT. ISBN 0-262-16123-0.  CS1 maint: Explicit use of et al. (link) pages 160-161 ^ Simulation of the IBM 650 on the IBM 705 ^ Data Processing System - Compatibility feature for IBM 704 programs ^ "System Compatibility Operations". Reference Manual IBM 7090 Data Processing System (PDF). March 1962. pp. 65–66. A22-6528-4.  ^ "System Compatibility Operations". IBM 1410 Principles of Operation (PDF). March 1962. pp. 56–57, 98–100. A22-0526-3.  ^ S. G. Tucker, "Emulation of Large Systems", Communications of the ACM (CACM) Vol. 8, No. 12, Dec. 1965, pp. 753-761 ^ Vinge, Vernor (1999). A Deepness in the Sky. Tor. pp. 224–227. ISBN 9780812536355.    External links[edit]    Look up emulate in Wiktionary, the free dictionary.      Look up Emulator in Wiktionary, the free dictionary.    (archived copy) is a repertory of emulators and their respective histories (site closed in 2010 due to copyright issues). Emulator at DMOZ        void WriteMemory(word Address, word Value) {     word RealAddress;     RealAddress = Address + BaseRegister;     if ((RealAddress < LimitRegister) &&         (RealAddress > ROMSIZE)) {         Memory[RealAddress] = Value;     } else {         RaiseInterrupt(INT_SEGFAULT);     } }     word ReadMemory(word Address) {     word RealAddress;     RealAddress=Address+BaseRegister;     if (RealAddress < LimitRegister) {         return Memory[RealAddress];     } else {         RaiseInterrupt(INT_SEGFAULT);         return NULL;     } }     void Execute(void) {     if (Interrupt != INT_NONE) {         SuperUser = TRUE;         WriteMemory(++StackPointer, ProgramCounter);         ProgramCounter = InterruptPointer;     }     switch (ReadMemory(ProgramCounter++)) {         /*          * Handling of every valid instruction          * goes here...          */         default:         Interrupt = INT_ILLEGAL;     } }  